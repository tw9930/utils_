<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
<!--
1. 区别call()/apply()/bind()
call(obj)/apply(obj): 调用函数, 指定函数中的this为第一个参数的值
bind(obj): 返回一个新的函数, 新函数内部会调用原来的函数, 且this为bind()指定的第一参数的值
注意: 如果obj是null/undefined, this为window
2. 应用
call()/bind()应用: 根据伪数组生成真数组
bind(): react中组件的自定义方法 / vue中的事件回调函数内部
3. 自定义call()/apply()
1). 给obj添加一个临时方法, 方法名任意, 值为当前函数
2). 通过obj调用这个临时方法, 并将接收的参数传入
3). 删除obj上的这个临时方法属性
4. 自定义实现bind()
1). 返回一个新函数
2). 在新函数内部通过原函数对象的call方法来执行原函数
指定原函数的this为obj
指定参数为bind调用的参数和后面新函数调用的参数
-->
<!--<script>-->
<!--    /*-->
<!--    1. 区别call()/apply()/bind()-->
<!--    call(obj)/apply(obj): 调用函数, 指定函数中的this为第一个参数的值-->
<!--    bind(obj): 返回一个新的函数, 新函数内部会调用原来的函数, 且this为bind()指定的第一参数的值-->
<!--    注意: 如果obj是null/undefined, this为window-->
<!--   */-->
<!--    Function.prototype.call=function (obj,...args){-->
<!--        let storage = this-->
<!--        //如果传入的参数是null或undefined，调用者是window-->
<!--        if (obj === null || obj === undefined){-->
<!--            storage(...args)-->
<!--        }else {-->
<!--            //改变函数的调用者为传入的第一个参数-->
<!--            obj.temp = storage-->
<!--            obj.temp(...args)-->
<!--            delete obj.temp-->
<!--        }-->
<!--    }-->
<!--    Function.prototype.apply=function (obj,args){-->
<!--        let storage = this-->
<!--        //如果传入的参数是null或undefined，调用者是window-->
<!--        if (obj === null || obj === undefined){-->
<!--            storage(...args)-->
<!--        }else {-->
<!--            //改变函数的调用者为传入的第一个参数-->
<!--            obj.temp = storage-->
<!--            obj.temp(...args)-->
<!--            delete obj.temp-->
<!--        }-->
<!--    }-->
<!--    Function.prototype.bind = function (obj,...args1){-->
<!--          const fn = this-->
<!--        return function (...args) {-->
<!--            fn.call(obj,...args1,...args)-->
<!--        }-->

<!--    }-->
<script src="../dist/utils.js"></script>
</script>
<script type="text/javascript">



function fn (a,b){
    // console.log(arguments.length)
    console.log(a,b,this)
}
let obj = {
    name:12
}
   // fn(1,2)
 // fn.call(null,3,4)
utils.call(fn,obj,1,2)

fn.apply(obj,[5,6])
 const fn1 = fn.bind(obj,1,2)
fn1(3,4)


</script>
</body>
</html>